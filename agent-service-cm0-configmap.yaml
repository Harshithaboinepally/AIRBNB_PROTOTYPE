apiVersion: v1
data:
  .env.example: |-
    HOST=0.0.0.0
    PORT=8000

    DB_HOST=localhost
    DB_USER=root
    DB_PASSWORD=your_mysql_password
    DB_NAME=airbnb_db
    DB_PORT=3306

    OPENAI_API_KEY=your-openai-api-key
    TAVILY_API_KEY=your-tavily-api-key

    FRONTEND_URL=http://localhost:3000
  Dockerfile: |
    # Use an official Python runtime as a parent image
    FROM python:3.9-slim-buster

    # Set the working directory in the container
    WORKDIR /app

    # Copy the requirements file into the container at /app
    COPY requirements.txt .

    # Install any needed packages specified in requirements.txt
    RUN pip install --no-cache-dir -r requirements.txt

    # Copy the rest of the application code to /app
    COPY . .

    # Expose the port that the FastAPI application runs on
    EXPOSE 8001

    # Run the Uvicorn server
    CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8001"]
  README.md: "# Airbnb Clone - AI Travel Assistant\n\nPython FastAPI service with Ollama integration \n\n## Quick Start\n```bash\n# Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# Windows:\nvenv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Start the service\npython main.py\n```\n\n##  AI Model Setup\n\n### Install Ollama\n```\n### Pull the Model\n```bash\n# Pull the lightweight model\nollama pull llama3.2:1b\n\n# Start Ollama server\nollama serve\n```\n\n## \U0001F4C1 Project Structure\n```\nagent-service/\n├── main.py              # FastAPI application\n├── requirements.txt     # Python dependencies\n├── .env                 # Environment variables\n└── venv/               # Virtual environment\n```\n\n## \U0001F527 Configuration\n\nCreate `.env` file:\n```env\nOLLAMA_URL=http://localhost:11434\nMODEL_NAME=llama3.2:1b\nDB_HOST=localhost\nDB_USER=root\nDB_PASSWORD=your_password\nDB_NAME=airbnb_db\nPORT=8001\n```\n\n## \U0001F4E6 Dependencies\n```txt\nfastapi==0.115.5\nuvicorn[standard]==0.32.1\npydantic==2.10.3\nrequests==2.32.3\npython-dotenv==1.0.1\ntyping-extensions==4.12.2\nmysql-connector-python==8.2.0\n```\n\n## \U0001F6E3️ API Endpoints\n\n### POST /chat\nSend a message to the AI assistant.\n\n**Request:**\n```json\n{\n  \"message\": \"Find properties in Paris\",\n  \"conversation_history\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"Hello\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"Hi! How can I help?\"\n    }\n  ],\n  \"user_context\": {\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\",\n    \"user_type\": \"traveler\"\n  }\n}\n```\n\n**Response:**\n```json\n{\n  \"response\": \"I found 5 properties in Paris...\",\n  \"suggestions\": [\n    \"Show me more details\",\n    \"Filter by price\",\n    \"Properties with WiFi\"\n  ]\n}\n```\n\n### GET /health\nHealth check endpoint.\n\n**Response:**\n```json\n{\n  \"status\": \"healthy\",\n  \"ollama\": \"connected\",\n  \"database\": \"connected\",\n  \"model\": \"llama3.2:1b\",\n  \"available_models\": [\"llama3.2:1b\", \"llama3.2\"]\n}\n```\n\n\n\n"
  main.py: "import os\nimport re\nimport sys\nfrom datetime import datetime\nfrom typing import List, Optional\n\nimport requests\nfrom bson.objectid import ObjectId\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel, Field\nfrom pymongo import MongoClient\n\napp = FastAPI(title=\"Airbnb AI Travel Assistant\")\n\n# CORS configuration\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:3000\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Ollama configuration\nOLLAMA_HOST = os.getenv(\"OLLAMA_HOST\", \"localhost\")\nOLLAMA_PORT = int(os.getenv(\"OLLAMA_PORT\", 11434))\nOLLAMA_URL = f\"http://{OLLAMA_HOST}:{OLLAMA_PORT}/api/generate\"\nMODEL_NAME = \"llama3.2:1b\"\nREQUEST_TIMEOUT = 60\nPORT = int(os.getenv(\"PORT\", 8001))\n\n# Database configuration\nDB_CONFIG = {\n    \"host\": os.getenv(\"DB_HOST\", \"localhost\"),\n    \"database\": os.getenv(\"DB_NAME\", \"airbnb_db\"),\n    \"port\": int(os.getenv(\"DB_PORT\", 27017)),\n}\n\ntry:\n    mongo_client = MongoClient(host=DB_CONFIG[\"host\"], port=DB_CONFIG[\"port\"])\n    db = mongo_client.get_database(DB_CONFIG[\"database\"])\n    print(\"✅ Successfully connected to MongoDB database\")\nexcept Exception as e:\n    print(f\"❌ Error connecting to MongoDB database: {e}\")\n    sys.exit(1)\n\n\nclass ChatMessage(BaseModel):\n    role: str = Field(..., description=\"Role of the message sender\")\n    content: str = Field(..., description=\"Content of the message\")\n\n\nclass ChatRequest(BaseModel):\n    message: str = Field(..., description=\"User's message\")\n    conversation_history: List[ChatMessage] = Field(default_factory=list)\n    user_context: Optional[dict] = None\n\n\nclass ChatResponse(BaseModel):\n    response: str = Field(..., description=\"AI assistant's response\")\n    suggestions: List[str] = Field(default_factory=list)\n\n\n# Improved system prompt\nSYSTEM_PROMPT = \"\"\"You are a friendly AI travel assistant for a vacation rental platform.\n\nYour role:\n- Help users search for vacation rental properties\n- Answer questions about bookings and amenities\n- Provide travel recommendations\n\nBe helpful, concise, and professional.\n\nCurrent date: {current_date}\n\"\"\"\n\n\n# Database helper functions\ndef get_user_properties(user_email: str = None, user_type: str = None):\n    \"\"\"Get properties from database\"\"\"\n    try:\n        properties_collection = db.properties\n        users_collection = db.users\n\n        query_filter = {}\n\n        if user_type == \"owner\" and user_email:\n            # Find the owner's user_id first\n            user_doc = users_collection.find_one({\"email\": user_email})\n            if user_doc:\n                query_filter = {\"owner_id\": user_doc[\"_id\"]}\n            else:\n                return []  # Owner not found\n\n            # Additional fields to select for owner properties\n            projection = {\n                \"property_id\": \"$_id\",  # Rename _id to property_id for consistency\n                \"property_name\": 1,\n                \"city\": 1,\n                \"country\": 1,\n                \"price_per_night\": 1,\n                \"bedrooms\": 1,\n                \"bathrooms\": 1,\n                \"property_type\": 1,\n                \"is_available\": 1,\n            }\n\n            properties = list(\n                properties_collection.find(query_filter, projection)\n                .sort(\"created_at\", -1)\n                .limit(10)\n            )\n\n            # Map _id to property_id in each document\n            for prop in properties:\n                prop[\"property_id\"] = str(prop[\"_id\"])\n                del prop[\"_id\"]\n\n        else:\n            query_filter = {\"is_available\": True}\n            projection = {\n                \"property_id\": \"$_id\",  # Rename _id to property_id\n                \"property_name\": 1,\n                \"city\": 1,\n                \"country\": 1,\n                \"price_per_night\": 1,\n                \"bedrooms\": 1,\n                \"bathrooms\": 1,\n                \"property_type\": 1,\n            }\n            properties = list(\n                properties_collection.find(query_filter, projection)\n                .sort(\"created_at\", -1)\n                .limit(10)\n            )\n\n            # Map _id to property_id in each document\n            for prop in properties:\n                prop[\"property_id\"] = str(prop[\"_id\"])\n                del prop[\"_id\"]\n\n        return properties\n    except Exception as e:  # Catch broader exceptions for MongoDB errors\n        print(f\"Database error: {e}\")\n        return []\n\n\ndef get_user_favorites(user_email: str):\n    \"\"\"Get user's favorite properties\"\"\"\n    try:\n        favorites_collection = db.favorites\n        users_collection = db.users\n\n        # Find the user's _id first\n        user_doc = users_collection.find_one({\"email\": user_email})\n        if not user_doc:\n            return []  # User not found\n\n        user_id = user_doc[\"_id\"]\n\n        pipeline = [\n            {\"$match\": {\"user_id\": user_id}},\n            {\n                \"$lookup\": {\n                    \"from\": \"properties\",  # The collection to join with\n                    \"localField\": \"property_id\",\n                    \"foreignField\": \"_id\",\n                    \"as\": \"propertyDetails\",\n                }\n            },\n            {\n                \"$unwind\": \"$propertyDetails\"  # Deconstruct the propertyDetails array\n            },\n            {\n                \"$project\": {\n                    \"_id\": 0,  # Exclude the favorite's _id\n                    \"property_id\": \"$propertyDetails._id\",  # Map property _id to property_id\n                    \"property_name\": \"$propertyDetails.property_name\",\n                    \"city\": \"$propertyDetails.city\",\n                    \"country\": \"$propertyDetails.country\",\n                    \"price_per_night\": \"$propertyDetails.price_per_night\",\n                    \"bedrooms\": \"$propertyDetails.bedrooms\",\n                    \"bathrooms\": \"$propertyDetails.bathrooms\",\n                    \"property_type\": \"$propertyDetails.property_type\",\n                    \"created_at\": \"$created_at\",  # Include favorite created_at for sorting\n                }\n            },\n            {\n                \"$sort\": {\"created_at\": -1}  # Sort by favorite created_at\n            },\n            {\"$limit\": 10},\n        ]\n\n        properties = list(favorites_collection.aggregate(pipeline))\n\n        # Convert ObjectId to string for property_id\n        for prop in properties:\n            if \"_id\" in prop:\n                del prop[\"_id\"]  # Ensure _id is removed\n            prop[\"property_id\"] = str(prop[\"property_id\"])\n            # Remove created_at if it's not needed in the final output, as it was just for sorting\n            if \"created_at\" in prop:\n                del prop[\"created_at\"]\n\n        return properties\n    except Exception as e:\n        print(f\"Database error in get_user_favorites: {e}\")\n        return []\n\n\ndef search_properties(\n    city: str = None,\n    max_price: float = None,\n    amenity: str = None,\n    bedrooms: int = None,\n    bathrooms: int = None,\n):\n    \"\"\"Search properties based on criteria\"\"\"\n    try:\n        properties_collection = db.properties\n\n        query_filter = {\"is_available\": True}\n\n        if city:\n            query_filter[\"$or\"] = [\n                {\"city\": {\"$regex\": city, \"$options\": \"i\"}},  # Case-insensitive search\n                {\n                    \"country\": {\"$regex\": city, \"$options\": \"i\"}\n                },  # Case-insensitive search\n            ]\n\n        if (\n            max_price is not None\n        ):  # Check for None explicitly to allow 0 as a valid price\n            query_filter[\"price_per_night\"] = {\"$lte\": max_price}\n\n        if amenity:\n            # Assuming amenities is an array of strings in MongoDB\n            # This will match if any amenity in the array contains the substring\n            query_filter[\"amenities\"] = {\"$regex\": amenity, \"$options\": \"i\"}\n\n        if bedrooms is not None:\n            query_filter[\"bedrooms\"] = bedrooms\n\n        if bathrooms is not None:\n            query_filter[\"bathrooms\"] = bathrooms\n\n        projection = {\n            \"property_id\": \"$_id\",  # Rename _id to property_id\n            \"property_name\": 1,\n            \"city\": 1,\n            \"country\": 1,\n            \"price_per_night\": 1,\n            \"bedrooms\": 1,\n            \"bathrooms\": 1,\n            \"property_type\": 1,\n            \"amenities\": 1,  # Include amenities in the projection\n        }\n\n        properties = list(\n            properties_collection.find(query_filter, projection)\n            .sort(\"created_at\", -1)\n            .limit(10)\n        )\n\n        # Map _id to property_id in each document\n        for prop in properties:\n            prop[\"property_id\"] = str(prop[\"_id\"])\n            del prop[\"_id\"]\n\n        return properties\n    except Exception as e:\n        print(f\"Database error in search_properties: {e}\")\n        return []\n\n\ndef get_user_bookings(user_email: str):\n    \"\"\"Get user's bookings\"\"\"\n    try:\n        bookings_collection = db.bookings\n        users_collection = db.users\n\n        # Find the user's _id first\n        user_doc = users_collection.find_one({\"email\": user_email})\n        if not user_doc:\n            return []  # User not found\n\n        user_id = user_doc[\"_id\"]\n\n        pipeline = [\n            {\"$match\": {\"traveler_id\": user_id}},\n            {\n                \"$lookup\": {\n                    \"from\": \"properties\",  # The collection to join with\n                    \"localField\": \"property_id\",\n                    \"foreignField\": \"_id\",\n                    \"as\": \"propertyDetails\",\n                }\n            },\n            {\n                \"$unwind\": \"$propertyDetails\"  # Deconstruct the propertyDetails array\n            },\n            {\n                \"$project\": {\n                    \"_id\": 0,  # Exclude the booking's _id\n                    \"booking_id\": \"$_id\",  # Map booking _id to booking_id\n                    \"check_in_date\": 1,\n                    \"check_out_date\": 1,\n                    \"num_guests\": 1,\n                    \"total_price\": 1,\n                    \"status\": 1,\n                    \"property_name\": \"$propertyDetails.property_name\",\n                    \"city\": \"$propertyDetails.city\",\n                    \"country\": \"$propertyDetails.country\",\n                    \"booking_date\": 1,  # Include booking_date for sorting\n                }\n            },\n            {\n                \"$sort\": {\"booking_date\": -1}  # Sort by booking_date\n            },\n            {\"$limit\": 5},\n        ]\n\n        bookings = list(bookings_collection.aggregate(pipeline))\n\n        # Convert ObjectId to string for booking_id\n        for booking in bookings:\n            if \"booking_id\" in booking:\n                booking[\"booking_id\"] = str(booking[\"booking_id\"])\n            # Remove booking_date if it's not needed in the final output, as it was just for sorting\n            if \"booking_date\" in booking:\n                del booking[\"booking_date\"]\n\n        return bookings\n    except Exception as e:\n        print(f\"Database error in get_user_bookings: {e}\")\n        return []\n\n\ndef format_properties_for_ai(properties: list) -> str:\n    \"\"\"Format properties list for AI response\"\"\"\n    if not properties:\n        return \"No properties found matching your criteria.\"\n\n    result = f\"I found {len(properties)} properties for you:\\n\\n\"\n    for i, prop in enumerate(properties, 1):\n        status = \" (Unavailable)\" if not prop.get(\"is_available\", True) else \"\"\n        result += f\"{i}. **{prop['property_name']}**{status}\\n\"\n        result += f\"    {prop['city']}, {prop['country']}\\n\"\n        result += f\"    ${prop['price_per_night']}/night\\n\"\n        result += f\"    {prop['bedrooms']} bed • \U0001F6BF {prop['bathrooms']} bath\\n\"\n        result += f\"    {prop['property_type'].title()}\\n\\n\"\n\n    return result\n\n\ndef format_bookings_for_ai(bookings: list) -> str:\n    \"\"\"Format bookings list for AI response\"\"\"\n    if not bookings:\n        return \"You don't have any bookings yet.\"\n\n    result = f\"Here are your recent bookings:\\n\\n\"\n    for i, booking in enumerate(bookings, 1):\n        result += f\"{i}. **{booking['property_name']}**\\n\"\n        result += f\"    {booking['city']}, {booking['country']}\\n\"\n        result += f\"    {booking['check_in_date']} to {booking['check_out_date']}\\n\"\n        result += f\"    {booking['num_guests']} guests\\n\"\n        result += f\"    ${booking['total_price']}\\n\"\n        result += f\"    Status: {booking['status']}\\n\\n\"\n\n    return result\n\n\ndef extract_number(text: str, keywords: list) -> int:\n    \"\"\"Extract number near keywords\"\"\"\n    text_lower = text.lower()\n    for keyword in keywords:\n        if keyword in text_lower:\n            # Find numbers near the keyword\n            pattern = rf\"(\\d+)\\s*{keyword}|{keyword}\\s*(\\d+)\"\n            match = re.search(pattern, text_lower)\n            if match:\n                num = match.group(1) or match.group(2)\n                return int(num)\n    return None\n\n\ndef extract_search_params(message: str) -> dict:\n    \"\"\"Extract search parameters from user message\"\"\"\n    message_lower = message.lower()\n    params = {}\n\n    # Extract bedrooms\n    bedrooms = extract_number(message, [\"bedroom\", \"bed\", \"br\"])\n    if bedrooms:\n        params[\"bedrooms\"] = bedrooms\n\n    # Extract bathrooms\n    bathrooms = extract_number(message, [\"bathroom\", \"bath\", \"ba\"])\n    if bathrooms:\n        params[\"bathrooms\"] = bathrooms\n\n    # Extract city - improved logic\n    city_keywords = [\"in\", \"near\", \"at\", \"around\"]\n    for keyword in city_keywords:\n        if keyword + \" \" in message_lower:\n            parts = message_lower.split(keyword + \" \")\n            if len(parts) > 1:\n                # Get the next 1-3 words after the keyword\n                city_words = parts[1].strip().split()[:3]\n                # Remove common words\n                stop_words = [\"a\", \"the\", \"with\", \"and\", \"or\", \"property\", \"properties\"]\n                city_words = [w for w in city_words if w not in stop_words]\n                if city_words:\n                    params[\"city\"] = (\n                        \" \".join(city_words).replace(\",\", \"\").replace(\".\", \"\")\n                    )\n                    break\n\n    # Extract price\n    if any(\n        word in message_lower\n        for word in [\"under\", \"below\", \"less than\", \"max\", \"maximum\"]\n    ):\n        # Find price with $ or just number\n        price_match = re.search(r\"\\$?(\\d+)\", message_lower)\n        if price_match:\n            params[\"max_price\"] = float(price_match.group(1))\n\n    # Extract amenities\n    amenities = [\n        \"pool\",\n        \"wifi\",\n        \"parking\",\n        \"kitchen\",\n        \"gym\",\n        \"beach\",\n        \"balcony\",\n        \"ac\",\n        \"garden\",\n    ]\n    for amenity in amenities:\n        if amenity in message_lower:\n            params[\"amenity\"] = amenity\n            break\n\n    return params\n\n\ndef create_prompt(\n    message: str,\n    conversation_history: List[ChatMessage],\n    user_context: Optional[dict] = None,\n) -> str:\n    \"\"\"Create a formatted prompt for Ollama\"\"\"\n    current_date = datetime.now().strftime(\"%Y-%m-%d\")\n    prompt = SYSTEM_PROMPT.format(current_date=current_date)\n\n    if user_context:\n        prompt += f\"\\nUser: {user_context.get('name', 'Guest')}\"\n        if user_context.get(\"user_type\"):\n            prompt += f\" ({user_context['user_type']})\"\n        prompt += \"\\n\"\n\n    if conversation_history:\n        prompt += \"\\nRecent conversation:\\n\"\n        for msg in conversation_history[-3:]:\n            prompt += f\"{msg.role.capitalize()}: {msg.content}\\n\"\n\n    prompt += f\"\\nUser: {message}\\nAssistant:\"\n    return prompt\n\n\ndef get_suggestions(message: str, has_results: bool = False) -> List[str]:\n    \"\"\"Generate follow-up suggestions\"\"\"\n    message_lower = message.lower()\n\n    if \"property\" in message_lower or \"properties\" in message_lower:\n        if has_results:\n            return [\n                \"Show me more details\",\n                \"Filter by different criteria\",\n                \"Properties in another city\",\n            ]\n        else:\n            return [\n                \"Show all properties\",\n                \"Properties in Paris\",\n                \"Properties under $200\",\n            ]\n    elif \"booking\" in message_lower:\n        return [\"Cancel a booking\", \"Modify my booking\", \"Refund policy\"]\n    elif \"favorite\" in message_lower:\n        return [\"Add to favorites\", \"Remove from favorites\", \"Show property details\"]\n    else:\n        return [\"Search for properties\", \"View my bookings\", \"Show my favorites\"]\n\n\n@app.post(\"/chat\", response_model=ChatResponse)\nasync def chat(request: ChatRequest):\n    \"\"\"Main chat endpoint with property integration\"\"\"\n    try:\n        message_lower = request.message.lower()\n\n        # Handle \"my properties\" queries (for owners)\n        if any(phrase in message_lower for phrase in [\"my propert\", \"my listing\"]):\n            if request.user_context and request.user_context.get(\"email\"):\n                properties = get_user_properties(\n                    request.user_context.get(\"email\"),\n                    request.user_context.get(\"user_type\"),\n                )\n\n                if properties:\n                    properties_text = format_properties_for_ai(properties)\n                    ai_response = properties_text\n                    suggestions = [\n                        \"Add new property\",\n                        \"View bookings\",\n                        \"Update details\",\n                    ]\n                else:\n                    ai_response = \"You don't have any properties listed yet.\"\n                    suggestions = [\"Add a property\", \"Get started guide\", \"Help\"]\n\n                return ChatResponse(response=ai_response, suggestions=suggestions)\n\n        # Handle favorites queries\n        elif any(\n            phrase in message_lower\n            for phrase in [\"favorite\", \"favourite\", \"fav\", \"liked\"]\n        ):\n            if request.user_context and request.user_context.get(\"email\"):\n                properties = get_user_favorites(request.user_context.get(\"email\"))\n\n                if properties:\n                    properties_text = format_properties_for_ai(properties)\n                    ai_response = (\n                        f\"Here are your favorite properties:\\n\\n{properties_text}\"\n                    )\n                    suggestions = [\"View details\", \"Remove favorite\", \"Book now\"]\n                else:\n                    ai_response = (\n                        \"You haven't added any properties to your favorites yet.\"\n                    )\n                    suggestions = [\n                        \"Browse properties\",\n                        \"Popular destinations\",\n                        \"Help me search\",\n                    ]\n\n                return ChatResponse(response=ai_response, suggestions=suggestions)\n\n        # Handle \"my bookings\" queries (for travelers)\n        elif any(\n            phrase in message_lower\n            for phrase in [\"my booking\", \"my reservation\", \"my trip\", \"show booking\"]\n        ):\n            if request.user_context and request.user_context.get(\"email\"):\n                bookings = get_user_bookings(request.user_context.get(\"email\"))\n\n                if bookings:\n                    bookings_text = format_bookings_for_ai(bookings)\n                    ai_response = bookings_text\n                    suggestions = [\"Cancel booking\", \"Modify dates\", \"Contact host\"]\n                else:\n                    ai_response = \"You don't have any bookings yet.\"\n                    suggestions = [\"Find properties\", \"Popular destinations\", \"Help\"]\n\n                return ChatResponse(response=ai_response, suggestions=suggestions)\n\n        # Handle property search queries\n        elif any(\n            word in message_lower\n            for word in [\n                \"find\",\n                \"search\",\n                \"show\",\n                \"properties\",\n                \"property\",\n                \"hotel\",\n                \"accommodation\",\n            ]\n        ):\n            params = extract_search_params(request.message)\n\n            print(f\"Extracted params: {params}\")  # Debug\n\n            properties = search_properties(\n                city=params.get(\"city\"),\n                max_price=params.get(\"max_price\"),\n                amenity=params.get(\"amenity\"),\n                bedrooms=params.get(\"bedrooms\"),\n                bathrooms=params.get(\"bathrooms\"),\n            )\n\n            if properties:\n                properties_text = format_properties_for_ai(properties)\n                ai_response = properties_text\n            else:\n                search_criteria = []\n                if params.get(\"bedrooms\"):\n                    search_criteria.append(f\"{params['bedrooms']} bedrooms\")\n                if params.get(\"bathrooms\"):\n                    search_criteria.append(f\"{params['bathrooms']} bathrooms\")\n                if params.get(\"city\"):\n                    search_criteria.append(f\"in {params['city']}\")\n                if params.get(\"max_price\"):\n                    search_criteria.append(f\"under ${params['max_price']}\")\n                if params.get(\"amenity\"):\n                    search_criteria.append(f\"with {params['amenity']}\")\n\n                criteria_text = (\n                    \", \".join(search_criteria)\n                    if search_criteria\n                    else \"matching your criteria\"\n                )\n                ai_response = f\"I couldn't find any properties {criteria_text}.\\n\\nTry:\\n• Adjusting your filters\\n• Searching in a different city\\n• Increasing your budget\"\n\n            suggestions = get_suggestions(\n                request.message, has_results=len(properties) > 0\n            )\n            return ChatResponse(response=ai_response, suggestions=suggestions)\n\n        # For general questions, use AI\n        prompt = create_prompt(\n            request.message, request.conversation_history, request.user_context\n        )\n\n        ollama_request = {\n            \"model\": MODEL_NAME,\n            \"prompt\": prompt,\n            \"stream\": False,\n            \"options\": {\n                \"temperature\": 0.7,\n                \"top_p\": 0.9,\n                \"num_predict\": 300,\n                \"stop\": [\"\\nUser:\", \"\\nHuman:\"],\n                \"num_ctx\": 2048,\n            },\n        }\n\n        response = requests.post(\n            OLLAMA_URL, json=ollama_request, timeout=REQUEST_TIMEOUT\n        )\n        response.raise_for_status()\n\n        result = response.json()\n        ai_response = result.get(\"response\", \"\").strip()\n\n        if not ai_response:\n            ai_response = \"I apologize, but I couldn't generate a response. Please try rephrasing.\"\n\n        suggestions = get_suggestions(request.message)\n\n        return ChatResponse(response=ai_response, suggestions=suggestions)\n\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(\n            status_code=503,\n            detail=\"AI service unavailable. Please ensure Ollama is running.\",\n        )\n    except requests.exceptions.Timeout:\n        raise HTTPException(\n            status_code=504, detail=\"Request took too long. Try a shorter message.\"\n        )\n    except Exception as e:\n        print(f\"ERROR: {type(e).__name__}: {str(e)}\")\n        raise HTTPException(status_code=500, detail=f\"An error occurred: {str(e)}\")\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Health check endpoint\"\"\"\n    try:\n        ollama_response = requests.get(\"http://ollama:11434/api/tags\", timeout=5)\n        ollama_status = (\n            \"connected\" if ollama_response.status_code == 200 else \"disconnected\"\n        )\n\n        try:\n            # Attempt to ping the MongoDB server\n            mongo_client.admin.command(\"ping\")\n            db_status = \"connected\"\n        except Exception as e:\n            print(f\"MongoDB health check error: {e}\")\n            db_status = \"disconnected\"\n\n        models = []\n        if ollama_response.status_code == 200:\n            data = ollama_response.json()\n            models = [model.get(\"name\") for model in data.get(\"models\", [])]\n\n        return {\n            \"status\": \"healthy\",\n            \"ollama\": ollama_status,\n            \"database\": db_status,\n            \"model\": MODEL_NAME,  # Assuming MODEL_NAME is globally available\n            \"available_models\": models,\n        }\n    except Exception as e:\n        print(f\"Health check main error: {e}\")\n        return {\n            \"status\": \"degraded\",\n            \"ollama\": \"unknown\",\n            \"database\": \"unknown\",\n            \"model\": MODEL_NAME,  # Assuming MODEL_NAME is globally available\n        }\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint\"\"\"\n    return {\n        \"message\": \"AI Travel Assistant API\",\n        \"version\": \"2.1.0\",\n        \"model\": MODEL_NAME,\n        \"features\": [\n            \"Smart property search\",\n            \"Booking management\",\n            \"Favorites tracking\",\n            \"Travel recommendations\",\n        ],\n        \"endpoints\": {\n            \"chat\": \"/chat (POST)\",\n            \"health\": \"/health (GET)\",\n            \"docs\": \"/docs (GET)\",\n        },\n    }\n\n\nif __name__ == \"__main__\":\n    import uvicorn\n\n    print(\"=\" * 60)\n    print(\"\U0001F916 AI Travel Assistant v2.1\")\n    print(f\"\U0001F4CD http://localhost:{PORT}\")\n    print(f\"\U0001F9E0 Model: {MODEL_NAME}\")\n    print(f\"\U0001F4BE Database: {DB_CONFIG['database']}\")\n    print(\"=\" * 60)\n    uvicorn.run(app, host=\"0.0.0.0\", port=PORT, log_level=\"info\")\n"
  requirements.txt: |
    fastapi==0.115.5
    uvicorn[standard]==0.32.1
    pydantic==2.10.3
    requests==2.32.3
    python-dotenv==1.0.1
    typing-extensions==4.12.2
    pymongo==4.15.4
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: agent-service
  name: agent-service-cm0
