worker_processes auto;

events {
    worker_connections 1024;
}

http {
    include mime.types;
    default_type application/octet-stream;
    sendfile on;
    keepalive_timeout 65;

    # --- Centralized CORS Headers for all HTTP responses managed by Nginx ---
    add_header 'Access-Control-Allow-Origin' 'http://localhost:3000' always; # Specific origin
    add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, PATCH, DELETE, OPTIONS' always;
    add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;
    add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range' always;
    add_header 'Access-Control-Allow-Credentials' 'true' always;
    add_header 'Access-Control-Max-Age' 1728000 always;

    # Docker's internal DNS resolver is crucial here for resolving service names.
    # It must be defined in the http block.
    resolver 127.0.0.11 valid=5s;

    proxy_connect_timeout       60s;
    proxy_send_timeout          60s;
    proxy_read_timeout          60s;
    send_timeout                60s;

    # --- REMOVED: No explicit upstream blocks when using dynamic proxy_pass below ---
    # upstream auth_service { server auth-service:5001; }
    # upstream property_service { server property-service:5002; }
    # ... and so on ...

    # Define a map to dynamically select the target hostname for proxy_pass.
    # This will be the Docker Compose service name.
    map $service_name_var $target_hostname { # <-- New map name for clarity
        auth        auth-service;
        properties  property-service;
        users       user-service;
        bookings    booking-service;
        favorites   favorite-service;
        dashboard   dashboard-service;
        default     _invalid_host_; # Fallback for debugging
    }

    # Define a map to dynamically select the service port.
    map $service_name_var $target_port { # <-- New map name for clarity
        auth        5001;
        properties  5002;
        users       5003;
        bookings    5004;
        favorites   5005;
        dashboard   5006;
        default     80; # Fallback for debugging
    }


    server {
        listen 5000;
        server_name localhost;

        # --- CONSOLIDATED API GATEWAY LOCATION BLOCK (REGEX MATCH) ---
        location ~ ^/api/(auth|properties|users|bookings|favorites|dashboard)(.*)$ {
            set $service_name_var $1; # Captured service name (e.g., 'properties')
            set $api_path $2;         # Captured rest of path (e.g., '/search/')

            if ($request_method = 'OPTIONS') {
                return 204; # CORS headers are from http block.
            }

            # Rewrite the URI. Example: /api/properties/search/ -> /search/
            rewrite ^/api/$service_name_var(.*)$ $1 break; # <--- CRUCIAL REWRITE

            # Dynamically pass to the correct hostname and port.
            # Nginx will use the 'resolver' to find the IP of $target_hostname.
            # Example: http://property-service:5002/search/
            proxy_pass http://$target_hostname:$target_port;

            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Authorization $http_authorization;
            proxy_redirect off;
            proxy_cookie_path / /;

            proxy_http_version 1.1; # Robustness headers
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
        }

        # Default catch-all location for anything not matching /api/ routes
        location / {
            return 200 'Welcome to the Airbnb Microservices API Gateway!\nAll backend services are proxied on port 5000.\nAgent service is directly on :8001.\n';
        }
    }
}
